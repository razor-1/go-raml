{{- define "client_python" -}}
"""
a client for {{ .Name }}
auto-generated by go-raml python client generator
"""

import requests
from client_support import type_handler_value, timestamp_from_datetime

{{- range $importName := .Imports }}
from {{$importName}} import {{$importName}}
{{- end}}

SERVER_URL = '{{ .BaseURI }}'


class {{ .Name }}ClientException(Exception):
    pass


class {{ .Name }}ClientHTTPError({{ .Name }}ClientException):
    pass


class {{ .Name }}ClientUnsuccessfulResponse({{ .Name }}ClientException):
    pass


class {{ .Name }}Client(object):
    """
    {{ .Name }}Client implements a basic client for {{ .Name }} based on requests
    """
    def __init__(self, url=SERVER_URL, user=None, password=None, timeout_ms=5000):
        self.url = '{}{}'.format(url, '{{ .ClientURI }}')
        self.timeout = timeout_ms / 1000
        self.user = user
        self.password = password

    @staticmethod
    def _check_status_code(req):
        scode = req.status_code
        if scode < 200 or scode > 299:
            errmsg = 'Unsuccessful response (code {code}): {body}'.format(code=scode, body=req.text)
            raise {{ .Name }}ClientUnsuccessfulResponse(errmsg)

    @staticmethod
    def _process_query(query):
        if not query:
            return
        qparam = {}
        {{ range $qpName, $qpType := .QueryParameters -}}
        try:
            if '{{ $qpName }}' in query:
                qval = query['{{ $qpName }}']
                qparam['{{ $qpName }}'] = type_handler_value(qval) or str(qval)
        except (ValueError, TypeError, AttributeError):
            pass

        {{ end -}}

        return qparam

    def get(self, query=None):
        """
        get objects. assumption is that get returns an array. the query is a dict that can contain:
          {{- range $qpName, $qpType := .QueryParameters }}
          `{{ $qpName }}`: {{ $qpType }}
          {{- end }}
        """
        query_params = self._process_query(query)
        headers = {'content-type': '{{ .BodyMimeType }}'}
        req = requests.get(self.url, auth=(self.user, self.password), headers=headers, params=query_params, timeout=self.timeout)

        self._check_status_code(req)

        ctype = req.headers.get('content-type')
        if ctype != '{{ .BodyMimeType }}':
            raise {{ .Name }}ClientUnsuccessfulResponse('Unsuccessful response: content-type is not json: {ctype}'.format(ctype=ctype))

        # we got something
        # try to turn it into a list of objects
        objects = []
        for obj in req.json():
            {{- if .CustomResourceType }}
            objects.append({{ .BaseType }}(json=obj))
            {{- else }}
            objects.append(obj)
            {{- end }}

        return objects

    def post(self, obj):
        """
        POST a new {{ .Name }} to the server
        `obj` must be an {{ .Name }} object
        """
        try:
            req = requests.post(self.url, auth=(self.user, self.password),
                                timeout=self.timeout, json=obj.as_dict())
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout) as err:
            raise {{ .Name }}ClientHTTPError(err)

        self._check_status_code(req)
{{end -}}